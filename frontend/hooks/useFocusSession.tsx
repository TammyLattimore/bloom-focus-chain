"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs
*/
import { FocusSessionAddresses } from "@/abi/FocusSessionAddresses";
import { FocusSessionABI } from "@/abi/FocusSessionABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type FocusSessionInfoType = {
  abi: typeof FocusSessionABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves FocusSession contract metadata for the given EVM `chainId`.
 */
function getFocusSessionByChainId(
  chainId: number | undefined
): FocusSessionInfoType {
  if (!chainId) {
    return { abi: FocusSessionABI.abi };
  }

  const entry =
    FocusSessionAddresses[chainId.toString() as keyof typeof FocusSessionAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: FocusSessionABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: FocusSessionABI.abi,
  };
}

/**
 * Main FocusSession React hook for encrypted focus session tracking
 */
export const useFocusSession = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // States + Refs
  const [sessionCountHandle, setSessionCountHandle] = useState<string | undefined>(undefined);
  const [totalMinutesHandle, setTotalMinutesHandle] = useState<string | undefined>(undefined);
  const [weeklyGoalHandle, setWeeklyGoalHandle] = useState<string | undefined>(undefined);
  
  const [clearSessionCount, setClearSessionCount] = useState<ClearValueType | undefined>(undefined);
  const [clearTotalMinutes, setClearTotalMinutes] = useState<ClearValueType | undefined>(undefined);
  const [clearWeeklyGoal, setClearWeeklyGoal] = useState<ClearValueType | undefined>(undefined);
  
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isLogging, setIsLogging] = useState<boolean>(false);
  const [isSettingGoal, setIsSettingGoal] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const focusSessionRef = useRef<FocusSessionInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(false);
  const isDecryptingRef = useRef<boolean>(false);
  const isLoggingRef = useRef<boolean>(false);

  const isDecrypted = 
    sessionCountHandle && sessionCountHandle === clearSessionCount?.handle &&
    totalMinutesHandle && totalMinutesHandle === clearTotalMinutes?.handle;

  // FocusSession Contract Info
  const focusSession = useMemo(() => {
    const c = getFocusSessionByChainId(chainId);
    focusSessionRef.current = c;
    if (!c.address) {
      setMessage(`FocusSession deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!focusSession) return undefined;
    return Boolean(focusSession.address) && focusSession.address !== ethers.ZeroAddress;
  }, [focusSession]);

  const canRefresh = useMemo(() => {
    return focusSession.address && ethersReadonlyProvider && !isRefreshing;
  }, [focusSession.address, ethersReadonlyProvider, isRefreshing]);

  // Refresh handles from contract
  const refreshHandles = useCallback(() => {
    if (isRefreshingRef.current) return;
    if (!focusSessionRef.current?.chainId || !focusSessionRef.current?.address || !ethersReadonlyProvider || !ethersSigner) {
      setSessionCountHandle(undefined);
      setTotalMinutesHandle(undefined);
      setWeeklyGoalHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = focusSessionRef.current.chainId;
    const thisAddress = focusSessionRef.current.address;
    
    const contract = new ethers.Contract(
      thisAddress,
      focusSessionRef.current.abi,
      ethersSigner
    );

    Promise.all([
      contract.getSessionCount(),
      contract.getTotalMinutes(),
      contract.getWeeklyGoal(),
    ])
      .then(([sessionCount, totalMinutes, weeklyGoal]) => {
        if (sameChain.current(thisChainId) && thisAddress === focusSessionRef.current?.address) {
          setSessionCountHandle(sessionCount);
          setTotalMinutesHandle(totalMinutes);
          setWeeklyGoalHandle(weeklyGoal);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("Failed to fetch session data: " + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Auto refresh
  useEffect(() => {
    refreshHandles();
  }, [refreshHandles]);

  // Decrypt all handles
  const canDecrypt = useMemo(() => {
    return (
      focusSession.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      sessionCountHandle &&
      sessionCountHandle !== ethers.ZeroHash &&
      sessionCountHandle !== clearSessionCount?.handle
    );
  }, [focusSession.address, instance, ethersSigner, isRefreshing, isDecrypting, sessionCountHandle, clearSessionCount]);

  const decryptStats = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) return;
    if (!focusSession.address || !instance || !ethersSigner) return;

    // Check if all zero (not initialized)
    if (sessionCountHandle === ethers.ZeroHash) {
      setClearSessionCount({ handle: sessionCountHandle, clear: BigInt(0) });
      setClearTotalMinutes({ handle: totalMinutesHandle || ethers.ZeroHash, clear: BigInt(0) });
      setClearWeeklyGoal({ handle: weeklyGoalHandle || ethers.ZeroHash, clear: BigInt(0) });
      return;
    }

    const thisChainId = chainId;
    const thisAddress = focusSession.address;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Starting decryption...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== focusSessionRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [focusSession.address as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Decryption cancelled - context changed");
          return;
        }

        setMessage("Decrypting encrypted data...");

        const handlesToDecrypt = [];
        if (sessionCountHandle && sessionCountHandle !== ethers.ZeroHash) {
          handlesToDecrypt.push({ handle: sessionCountHandle, contractAddress: thisAddress });
        }
        if (totalMinutesHandle && totalMinutesHandle !== ethers.ZeroHash) {
          handlesToDecrypt.push({ handle: totalMinutesHandle, contractAddress: thisAddress });
        }
        if (weeklyGoalHandle && weeklyGoalHandle !== ethers.ZeroHash) {
          handlesToDecrypt.push({ handle: weeklyGoalHandle, contractAddress: thisAddress });
        }

        if (handlesToDecrypt.length === 0) {
          setClearSessionCount({ handle: sessionCountHandle || ethers.ZeroHash, clear: BigInt(0) });
          setClearTotalMinutes({ handle: totalMinutesHandle || ethers.ZeroHash, clear: BigInt(0) });
          setClearWeeklyGoal({ handle: weeklyGoalHandle || ethers.ZeroHash, clear: BigInt(0) });
          setMessage("No encrypted data to decrypt");
          return;
        }

        const res = await instance.userDecrypt(
          handlesToDecrypt,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        if (isStale()) {
          setMessage("Decryption cancelled - context changed");
          return;
        }

        if (sessionCountHandle) {
          setClearSessionCount({ handle: sessionCountHandle, clear: res[sessionCountHandle] ?? BigInt(0) });
        }
        if (totalMinutesHandle) {
          setClearTotalMinutes({ handle: totalMinutesHandle, clear: res[totalMinutesHandle] ?? BigInt(0) });
        }
        if (weeklyGoalHandle) {
          setClearWeeklyGoal({ handle: weeklyGoalHandle, clear: res[weeklyGoalHandle] ?? BigInt(0) });
        }

        setMessage("Decryption completed!");
      } catch (e) {
        setMessage("Decryption failed: " + e);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    focusSession.address,
    instance,
    sessionCountHandle,
    totalMinutesHandle,
    weeklyGoalHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  // Log Session
  const canLogSession = useMemo(() => {
    return focusSession.address && instance && ethersSigner && !isRefreshing && !isLogging;
  }, [focusSession.address, instance, ethersSigner, isRefreshing, isLogging]);

  const logSession = useCallback(
    async (minutes: number) => {
      if (isRefreshingRef.current || isLoggingRef.current) return;
      if (!focusSession.address || !instance || !ethersSigner || minutes <= 0) return;

      const thisChainId = chainId;
      const thisAddress = focusSession.address;
      const thisEthersSigner = ethersSigner;
      const contract = new ethers.Contract(thisAddress, focusSession.abi, thisEthersSigner);

      isLoggingRef.current = true;
      setIsLogging(true);
      setMessage(`Encrypting ${minutes} minutes...`);

      try {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== focusSessionRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        const input = instance.createEncryptedInput(thisAddress, thisEthersSigner.address);
        input.add32(minutes);
        const enc = await input.encrypt();

        if (isStale()) {
          setMessage("Operation cancelled - context changed");
          return;
        }

        setMessage("Submitting encrypted session to blockchain...");
        const tx = await contract.logSession(enc.handles[0], enc.inputProof);
        setMessage(`Waiting for tx: ${tx.hash}...`);
        const receipt = await tx.wait();
        setMessage(`Session logged! Status: ${receipt?.status}`);

        if (isStale()) return;
        refreshHandles();
      } catch (e) {
        setMessage("Failed to log session: " + e);
        throw e;
      } finally {
        isLoggingRef.current = false;
        setIsLogging(false);
      }
    },
    [ethersSigner, focusSession.address, focusSession.abi, instance, chainId, refreshHandles, sameChain, sameSigner]
  );

  // Set Weekly Goal
  const setWeeklyGoal = useCallback(
    async (goalMinutes: number) => {
      if (!focusSession.address || !instance || !ethersSigner || goalMinutes <= 0) return;

      const thisChainId = chainId;
      const thisAddress = focusSession.address;
      const thisEthersSigner = ethersSigner;
      const contract = new ethers.Contract(thisAddress, focusSession.abi, thisEthersSigner);

      setIsSettingGoal(true);
      setMessage(`Encrypting goal: ${goalMinutes} minutes...`);

      try {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== focusSessionRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        const input = instance.createEncryptedInput(thisAddress, thisEthersSigner.address);
        input.add32(goalMinutes);
        const enc = await input.encrypt();

        if (isStale()) {
          setMessage("Operation cancelled - context changed");
          return;
        }

        setMessage("Setting encrypted weekly goal...");
        const tx = await contract.setWeeklyGoal(enc.handles[0], enc.inputProof);
        setMessage(`Waiting for tx: ${tx.hash}...`);
        const receipt = await tx.wait();
        setMessage(`Goal set! Status: ${receipt?.status}`);

        if (isStale()) return;
        refreshHandles();
      } catch (e) {
        setMessage("Failed to set goal: " + e);
        throw e;
      } finally {
        setIsSettingGoal(false);
      }
    },
    [ethersSigner, focusSession.address, focusSession.abi, instance, chainId, refreshHandles, sameChain, sameSigner]
  );

  return {
    contractAddress: focusSession.address,
    isDeployed,
    canRefresh,
    canDecrypt,
    canLogSession,
    refreshHandles,
    decryptStats,
    logSession,
    setWeeklyGoal,
    isDecrypted,
    message,
    sessionCount: clearSessionCount?.clear,
    totalMinutes: clearTotalMinutes?.clear,
    weeklyGoal: clearWeeklyGoal?.clear,
    sessionCountHandle,
    totalMinutesHandle,
    weeklyGoalHandle,
    isRefreshing,
    isDecrypting,
    isLogging,
    isSettingGoal,
  };
};

